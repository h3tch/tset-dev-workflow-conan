# This file adheres to the tset C++ developer workflow.
# See the documentation in the Makefile for more information.
# Do not edit this file.

from conans import ConanFile, CMake, tools
import glob
import os

current_directory = os.path.join(os.path.dirname(os.path.abspath(__file__)))
is_header_only_library = len(glob.glob(os.path.join(current_directory, "src", "*"))) == 0

class CppDevContainerConan(ConanFile):
    license = "Proprietary"
    generators = "cmake"
    exports = "config"
    exports_sources = "include/*", "src/*", "tests/*", "CMakeLists.txt", "LICENSE"
    settings = "os", "compiler", "build_type", "arch"
    options = {"shared": [True, False]}
    default_options = {"shared": True}

    def __init__(self, *args, **kwargs):
        config = dict(load_config_file(os.path.join(current_directory, 'config')))

        CppDevContainerConan.name = config['PROJECT_NAME']
        CppDevContainerConan.version = config['PROJECT_VERSION']
        CppDevContainerConan.description = config.get('PROJECT_DESCRIPTION', None)
        CppDevContainerConan.url = config.get('PROJECT_URL', None)
        CONAN_USER = config.get('CONAN_USER', '')
        CONAN_CHANNEL = config.get('CONAN_CHANNEL', '')
        CONAN_REQUIRE = config.get('CONAN_REQUIRE', '')
        CppDevContainerConan.requires = parse_requirements(CONAN_REQUIRE, CONAN_USER, CONAN_CHANNEL)

        super().__init__(*args, **kwargs)

    def build(self):
        cmake = CMake(self)
        cmake.definitions["CMAKE_EXPORT_COMPILE_COMMANDS"] = True
        cmake.configure()
        cmake.build()
    
    def package(self):
        self.copy("*", dst="bin", src="bin", excludes=("test*", "*.so"))
        self.copy("*.h", dst="include", src="include")
        self.copy("*.hpp", dst="include", src="include")
        self.copy("*.so", dst="lib", src="lib", keep_path=False)

    def package_info(self):
        if os.path.exists('include'):
            self.cpp_info.includedirs = ["include"]
        if os.path.exists('lib'):
            self.cpp_info.libs = [CppDevContainerConan.name]
            self.env_info.LD_LIBRARY_PATH.append(os.path.join(self.package_folder, "lib"))
            self.env_info.DYLD_LIBRARY_PATH.append(os.path.join(self.package_folder, "lib"))

    def package_id(self):
        if is_header_only_library:
            self.info.header_only()
            
    def imports(self):
        self.copy("*", src="@bindirs", dst="bin")
        self.copy("*", src="@libdirs", dst="bin")


def load_config_file(filename): 
    with open(filename) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#') or '=' not in line:
                continue

            k, v = line.split('=', 1)
            k, v = k.strip(), v.strip()

            if len(v) > 0:
                quoted = v[0] == v[len(v) - 1] in ['"', "'"]
                if quoted:
                    v = v[1:-1]

            yield k, v


def parse_requirement(requirement):
    package, version, user, channel = None, None, None, None

    package_repo = requirement.split('@')

    if len(package_repo) >= 1:
        package_version = package_repo[0].split('/')
        if len(package_version) >= 1:
            package = package_version[0]
        if len(package_version) >= 2:
            version = package_version[1]

    if len(package_repo) >= 2:
        user_channel = package_repo[1].split('/')
        if len(user_channel) >= 1:
            user = user_channel[0]
        if len(user_channel) >= 2:
            channel = user_channel[1]
    
    return package, version, user, channel


def set_empty_user_channel(requirement, user, default_channel):
    package, version, user_name, channel = parse_requirement(requirement)

    if user_name == user and channel is None:
        channel = default_channel

    return f'{package}/{version}@{user_name}/{channel}'


def parse_requirements(requirements, user, default_channel):
    requirements = [set_empty_user_channel(r, user, default_channel)
                    for r in requirements.split(',') if len(r) > 0]
    return requirements if len(requirements) > 0 else None
