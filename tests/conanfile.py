# This file adheres to the tset C++ developer workflow.
# See the documentation in the Makefile for more information.
# Do not edit this file.

from conans import ConanFile, CMake
import glob
import os


class CppDevContainerTestConan(ConanFile):
    settings = "os", "compiler", "build_type", "arch"
    generators = "cmake"

    def __init__(self, *args, **kwargs):
        config = dict(load_config_file('config'))
        CONAN_USER = config.get('CONAN_USER', '')
        CONAN_CHANNEL = config.get('CONAN_CHANNEL', '')
        CONAN_REQUIRE = config.get('CONAN_REQUIRE', '')
        CppDevContainerConan.requires = parse_requirements(CONAN_REQUIRE, CONAN_USER, CONAN_CHANNEL)
        super().__init__(*args, **kwargs)

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def test(self):
        for test_file in glob.glob(os.path.join("bin", "test*")):
            self.run(f"LD_LIBRARY_PATH={os.path.abspath('bin')} {test_file}")


def load_config_file(filename): 
    with open(filename) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#') or '=' not in line:
                continue

            k, v = line.split('=', 1)
            k, v = k.strip(), v.strip()

            if len(v) > 0:
                quoted = v[0] == v[len(v) - 1] in ['"', "'"]
                if quoted:
                    v = v[1:-1]

            yield k, v

def parse_requirement(requirement):
    package, version, user, channel = None, None, None, None

    package_repo = requirement.split('@')

    if len(package_repo) >= 1:
        package_version = package_repo[0].split('/')
        if len(package_version) >= 1:
            package = package_version[0]
        if len(package_version) >= 2:
            version = package_version[1]

    if len(package_repo) >= 2:
        user_channel = package_repo[1].split('/')
        if len(user_channel) >= 1:
            user = user_channel[0]
        if len(user_channel) >= 2:
            channel = user_channel[1]
    
    return package, version, user, channel


def set_empty_user_channel(requirement, user, default_channel):
    package, version, user_name, channel = parse_requirement(requirement)

    if user_name == user and channel is None:
        channel = default_channel

    return f'{package}/{version}@{user_name}/{channel}'


def parse_requirements(requirements, user, default_channel):
    requirements = [set_empty_user_channel(r, user, default_channel)
                    for r in requirements.split(',') if len(r) > 0]
    return requirements if len(requirements) > 0 else None
